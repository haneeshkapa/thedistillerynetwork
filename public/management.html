<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SMS Bot Admin Dashboard</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
    h1, h2, h3 { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: #333; }
    .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .section { margin-bottom: 40px; border: 1px solid #ddd; padding: 20px; border-radius: 6px; }
    .section h2 { margin-top: 0; color: #d4510a; }
    
    #conv-list { max-height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; background: #fafafa; }
    #conv-list li { cursor: pointer; margin: 8px 0; padding: 8px; background: white; border-radius: 4px; border-left: 4px solid #28a745; }
    #conv-list li.paused { border-left-color: #dc3545; background: #f8d7da; }
    #conv-list li.requested-human { border-left-color: #ffc107; background: #fff3cd; }
    #conv-list li:hover { background: #e9ecef; }
    
    #conv-messages { max-height: 400px; overflow-y: auto; white-space: pre-wrap; background: #f9f9f9; padding: 15px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; }
    #conv-messages .user { color: #0066cc; font-weight: bold; }
    #conv-messages .assistant { color: #009900; font-weight: bold; }
    #conv-messages .timestamp { color: #666; font-size: 0.9em; }
    
    #logs { max-height: 200px; overflow-y: auto; background: #f4f4f4; padding: 10px; font-size: 0.9em; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; }
    .log-error { color: #dc3545; }
    .log-warning { color: #ffc107; }
    .log-info { color: #17a2b8; }
    
    textarea { width: 100%; height: 120px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; }
    input[type=text] { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }
    button { margin: 5px; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; }
    .btn-primary { background: #007bff; color: white; }
    .btn-success { background: #28a745; color: white; }
    .btn-warning { background: #ffc107; color: black; }
    .btn-danger { background: #dc3545; color: white; }
    .btn-secondary { background: #6c757d; color: white; }
    
    .hidden { display: none; }
    .status-message { margin: 10px 0; padding: 10px; border-radius: 4px; }
    .status-success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
    .status-error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
    
    #kb-list { max-height: 300px; overflow-y: auto; }
    #kb-list li { margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 4px; border-left: 4px solid #6c757d; }
    #kb-list .shopify { border-left-color: #28a745; }
    #kb-list .manual { border-left-color: #007bff; }
    
    .stats { display: flex; gap: 20px; margin-bottom: 20px; }
    .stat-card { flex: 1; padding: 15px; background: #e9ecef; border-radius: 6px; text-align: center; }
    .stat-number { font-size: 2em; font-weight: bold; color: #d4510a; }
    .stat-label { color: #6c757d; }
  </style>
</head>
<body>
  <div class="container">
    <h1>ü•É SMS Bot Admin Dashboard</h1>
    <p>Jonathan's Distillation SMS Bot Management Interface</p>

    <!-- Stats Section -->
    <div class="section">
      <h2>üìä System Status</h2>
      <div class="stats" id="stats">
        <div class="stat-card">
          <div class="stat-number" id="total-conversations">0</div>
          <div class="stat-label">Total Conversations</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="active-conversations">0</div>
          <div class="stat-label">Active Today</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="paused-conversations">0</div>
          <div class="stat-label">Paused (Human)</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="knowledge-entries">0</div>
          <div class="stat-label">Knowledge Entries</div>
        </div>
      </div>
    </div>

    <!-- Conversations Section -->
    <div class="section">
      <h2>üí¨ Conversations</h2>
      <button id="refresh-conversations-btn" class="btn-secondary">Refresh Conversations</button>
      <ul id="conv-list"></ul>
      <div id="conv-detail" class="hidden">
        <h3>Conversation with <span id="conv-name"></span> (<span id="conv-phone"></span>)</h3>
        <p><strong>Status:</strong> <span id="conv-status"></span></p>
        <button id="pause-resume-btn" class="btn-warning"></button>
        <div id="conv-messages"></div>
      </div>
    </div>

    <!-- Personality Section -->
    <div class="section">
      <h2>ü§ñ Bot Personality</h2>
      <p>Edit the personality/system prompt for the AI:</p>
      <textarea id="personality-text" placeholder="Loading personality..."></textarea><br>
      <button id="save-personality-btn" class="btn-primary">Save Personality</button>
      <div id="personality-status" class="status-message hidden"></div>
    </div>

    <!-- Knowledge Base Section -->
    <div class="section">
      <h2>üìö Knowledge Base</h2>
      <div style="margin-bottom: 15px;">
        <button id="sync-shopify-btn" class="btn-success">üîÑ Sync from Shopify</button>
        <button id="refresh-knowledge-btn" class="btn-secondary">Refresh Knowledge</button>
      </div>
      
      <h3>Add New Knowledge Entry</h3>
      <input type="text" id="kb-title" placeholder="Title"><br><br>
      <textarea id="kb-content" placeholder="Content"></textarea><br>
      <button id="add-kb-btn" class="btn-primary">Add Entry</button>
      <div id="kb-add-status" class="status-message hidden"></div>
      
      <h3>Existing Entries</h3>
      <ul id="kb-list"></ul>
    </div>

    <!-- Logs Section -->
    <div class="section">
      <h2>üìù System Logs</h2>
      <button id="refresh-logs-btn" class="btn-secondary">Refresh Logs</button>
      <div id="logs"></div>
    </div>
  </div>

<script>
// Helper function for escaping HTML (to prevent XSS in logs or messages)
function escapeHTML(str) {
  if (!str) return '';
  return str.replace(/[&<>"'`]/g, (c) => {
    return { '&': '&amp;', '<': '&lt;', '>': '&gt;', '\"': '&quot;', '\'': '&#39;', '`': '&#96;' }[c];
  });
}

// Format timestamp
function formatTimestamp(timestamp) {
  return new Date(timestamp).toLocaleString();
}

// Show status messages
function showStatus(elementId, message, isError = false) {
  const el = document.getElementById(elementId);
  el.textContent = message;
  el.className = `status-message ${isError ? 'status-error' : 'status-success'}`;
  el.classList.remove('hidden');
  setTimeout(() => el.classList.add('hidden'), 3000);
}

// Load and update stats
async function loadStats() {
  try {
    const [convRes, kbRes] = await Promise.all([
      fetch('/api/conversations'),
      fetch('/api/knowledge')
    ]);
    
    const conversations = await convRes.json();
    const knowledge = await kbRes.json();
    
    const today = new Date().toDateString();
    const activeToday = conversations.filter(c => 
      new Date(c.last_active).toDateString() === today
    ).length;
    const paused = conversations.filter(c => c.paused).length;
    
    document.getElementById('total-conversations').textContent = conversations.length;
    document.getElementById('active-conversations').textContent = activeToday;
    document.getElementById('paused-conversations').textContent = paused;
    document.getElementById('knowledge-entries').textContent = knowledge.length;
  } catch (error) {
    console.error('Failed to load stats:', error);
  }
}

// Load conversations list
async function loadConversations() {
  try {
    const res = await fetch('/api/conversations');
    const convs = await res.json();
    const convList = document.getElementById('conv-list');
    convList.innerHTML = '';
    
    convs.forEach(conv => {
      const li = document.createElement('li');
      let statusClass = '';
      let statusText = '';
      
      if (conv.paused && conv.requested_human) {
        statusClass = 'requested-human';
        statusText = ' (üôã NEEDS HUMAN)';
      } else if (conv.paused) {
        statusClass = 'paused';
        statusText = ' (‚è∏Ô∏è PAUSED)';
      }
      
      li.className = statusClass;
      li.textContent = `${conv.name || 'Unknown'} - ${conv.phone}${statusText}`;
      li.onclick = () => showConversation(conv.phone);
      convList.appendChild(li);
    });
  } catch (error) {
    console.error('Failed to load conversations:', error);
  }
}

// Show conversation detail and messages
async function showConversation(phone) {
  try {
    const res = await fetch('/api/conversation/' + phone);
    if (!res.ok) {
      alert('Failed to load conversation.');
      return;
    }
    
    const data = await res.json();
    const convo = data.conversation;
    const messages = data.messages;
    
    document.getElementById('conv-detail').classList.remove('hidden');
    document.getElementById('conv-name').textContent = convo.name || "Unknown";
    document.getElementById('conv-phone').textContent = convo.phone;
    
    let statusText = "Active";
    if (convo.paused && convo.requested_human) {
      statusText = "Paused (User requested human) üôã";
    } else if (convo.paused) {
      statusText = "Paused (Manually) ‚è∏Ô∏è";
    }
    document.getElementById('conv-status').textContent = statusText;
    
    const btn = document.getElementById('pause-resume-btn');
    if (convo.paused) {
      btn.textContent = "‚ñ∂Ô∏è Resume AI";
      btn.className = "btn-success";
      btn.onclick = async () => {
        await fetch('/api/conversation/' + phone + '/resume', { method: 'POST' });
        showConversation(phone);
        loadConversations();
        loadStats();
      };
    } else {
      btn.textContent = "‚è∏Ô∏è Pause AI (take over)";
      btn.className = "btn-warning";
      btn.onclick = async () => {
        await fetch('/api/conversation/' + phone + '/pause', { method: 'POST' });
        showConversation(phone);
        loadConversations();
        loadStats();
      };
    }
    
    // Display messages
    const msgDiv = document.getElementById('conv-messages');
    msgDiv.innerHTML = '';
    
    messages.forEach(msg => {
      const p = document.createElement('div');
      const time = formatTimestamp(msg.timestamp);
      
      if (msg.sender === 'user') {
        p.innerHTML = `<span class="timestamp">[${time}]</span><br><span class="user">Customer:</span> ${escapeHTML(msg.message)}<br><br>`;
      } else {
        p.innerHTML = `<span class="timestamp">[${time}]</span><br><span class="assistant">Bot:</span> ${escapeHTML(msg.message)}<br><br>`;
      }
      msgDiv.appendChild(p);
    });
    msgDiv.scrollTop = msgDiv.scrollHeight;
  } catch (error) {
    console.error('Failed to load conversation:', error);
  }
}

// Load personality text
async function loadPersonality() {
  try {
    const res = await fetch('/api/personality');
    const data = await res.json();
    document.getElementById('personality-text').value = data.content || '';
  } catch (error) {
    console.error('Failed to load personality:', error);
  }
}

// Save personality text
document.getElementById('save-personality-btn').onclick = async () => {
  const text = document.getElementById('personality-text').value;
  try {
    const res = await fetch('/api/personality', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ content: text })
    });
    
    if (res.ok) {
      showStatus('personality-status', 'Personality saved successfully!');
    } else {
      showStatus('personality-status', 'Failed to save personality.', true);
    }
  } catch (error) {
    console.error('Failed to save personality:', error);
    showStatus('personality-status', 'Failed to save personality.', true);
  }
};

// Load knowledge base entries
async function loadKnowledge() {
  try {
    const res = await fetch('/api/knowledge');
    const list = await res.json();
    const kbList = document.getElementById('kb-list');
    kbList.innerHTML = '';
    
    list.forEach(entry => {
      const li = document.createElement('li');
      li.className = entry.source || 'manual';
      
      const sourceIcon = entry.source === 'shopify' ? 'üõçÔ∏è' : 'üìù';
      const dateStr = formatTimestamp(entry.created_at);
      
      li.innerHTML = `
        <strong>${sourceIcon} ${escapeHTML(entry.title)}</strong><br>
        <small>${escapeHTML(entry.snippet)}... [${entry.source || 'manual'}] - ${dateStr}</small>
      `;
      
      if (entry.source === 'manual') {
        const delBtn = document.createElement('button');
        delBtn.textContent = "üóëÔ∏è Delete";
        delBtn.className = "btn-danger";
        delBtn.style.marginTop = '5px';
        delBtn.onclick = async () => {
          if (confirm('Delete this entry?')) {
            try {
              await fetch('/api/knowledge/' + entry.id, { method: 'DELETE' });
              loadKnowledge();
              loadStats();
            } catch (error) {
              console.error('Failed to delete entry:', error);
            }
          }
        };
        li.appendChild(delBtn);
      }
      
      kbList.appendChild(li);
    });
  } catch (error) {
    console.error('Failed to load knowledge:', error);
  }
}

// Add knowledge entry
document.getElementById('add-kb-btn').onclick = async () => {
  const title = document.getElementById('kb-title').value;
  const content = document.getElementById('kb-content').value;
  
  if (!title || !content) {
    showStatus('kb-add-status', 'Please provide title and content.', true);
    return;
  }
  
  try {
    const res = await fetch('/api/knowledge', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ title, content })
    });
    
    if (res.ok) {
      showStatus('kb-add-status', 'Knowledge entry added successfully!');
      document.getElementById('kb-title').value = "";
      document.getElementById('kb-content').value = "";
      loadKnowledge();
      loadStats();
    } else {
      showStatus('kb-add-status', 'Failed to add knowledge entry.', true);
    }
  } catch (error) {
    console.error('Failed to add knowledge:', error);
    showStatus('kb-add-status', 'Failed to add knowledge entry.', true);
  }
};

// Sync Shopify button
document.getElementById('sync-shopify-btn').onclick = async () => {
  if (!confirm('Fetch latest products from Shopify and update knowledge base?')) {
    return;
  }
  
  const btn = document.getElementById('sync-shopify-btn');
  btn.disabled = true;
  btn.textContent = 'üîÑ Syncing...';
  
  try {
    const res = await fetch('/api/sync-shopify', { method: 'POST' });
    const data = await res.json();
    
    if (res.ok) {
      alert(`Synced ${data.count || 0} products from Shopify successfully!`);
      loadKnowledge();
      loadStats();
    } else {
      alert('Sync failed: ' + (data.error || 'Unknown error'));
    }
  } catch (error) {
    console.error('Sync failed:', error);
    alert('Sync failed: ' + error.message);
  } finally {
    btn.disabled = false;
    btn.textContent = 'üîÑ Sync from Shopify';
  }
};

// Load logs
async function loadLogs() {
  try {
    const res = await fetch('/api/logs');
    const logs = await res.json();
    const logDiv = document.getElementById('logs');
    logDiv.innerHTML = '';
    
    logs.forEach(entry => {
      const time = formatTimestamp(entry.timestamp);
      const line = `[${time}] [${entry.level.toUpperCase()}] ${entry.message}`;
      const p = document.createElement('div');
      p.textContent = line;
      p.className = `log-${entry.level}`;
      logDiv.appendChild(p);
    });
    
    logDiv.scrollTop = logDiv.scrollHeight;
  } catch (error) {
    console.error('Failed to load logs:', error);
  }
}

// Event listeners for refresh buttons
document.getElementById('refresh-conversations-btn').onclick = () => {
  loadConversations();
  loadStats();
};
document.getElementById('refresh-knowledge-btn').onclick = loadKnowledge;
document.getElementById('refresh-logs-btn').onclick = loadLogs;

// Initialize the dashboard
async function initDashboard() {
  await Promise.all([
    loadStats(),
    loadConversations(),
    loadPersonality(),
    loadKnowledge(),
    loadLogs()
  ]);
}

// Auto-refresh every 30 seconds
setInterval(() => {
  loadStats();
  loadConversations();
}, 30000);

// Initialize on page load
initDashboard();
</script>
</body>
</html>